// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mychain/dex/v1/types.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Order defines a trading order
type Order struct {
	Id           uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Maker        string     `protobuf:"bytes,2,opt,name=maker,proto3" json:"maker,omitempty"`
	PairId       uint64     `protobuf:"varint,3,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	IsBuy        bool       `protobuf:"varint,4,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	Price        types.Coin `protobuf:"bytes,5,opt,name=price,proto3" json:"price"`
	Amount       types.Coin `protobuf:"bytes,6,opt,name=amount,proto3" json:"amount"`
	FilledAmount types.Coin `protobuf:"bytes,7,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount"`
	CreatedAt    int64      `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt    int64      `protobuf:"varint,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{0}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetMaker() string {
	if m != nil {
		return m.Maker
	}
	return ""
}

func (m *Order) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *Order) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *Order) GetPrice() types.Coin {
	if m != nil {
		return m.Price
	}
	return types.Coin{}
}

func (m *Order) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *Order) GetFilledAmount() types.Coin {
	if m != nil {
		return m.FilledAmount
	}
	return types.Coin{}
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

// TradingPair defines a trading pair
type TradingPair struct {
	Id         uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BaseDenom  string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	Active     bool   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *TradingPair) Reset()         { *m = TradingPair{} }
func (m *TradingPair) String() string { return proto.CompactTextString(m) }
func (*TradingPair) ProtoMessage()    {}
func (*TradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{1}
}
func (m *TradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingPair.Merge(m, src)
}
func (m *TradingPair) XXX_Size() int {
	return m.Size()
}
func (m *TradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_TradingPair proto.InternalMessageInfo

func (m *TradingPair) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TradingPair) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *TradingPair) GetQuoteDenom() string {
	if m != nil {
		return m.QuoteDenom
	}
	return ""
}

func (m *TradingPair) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// LiquidityTier defines reward tiers based on price deviation
type LiquidityTier struct {
	Id                    uint32                      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PriceDeviation        cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price_deviation,json=priceDeviation,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price_deviation"`
	BidVolumeCap          cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=bid_volume_cap,json=bidVolumeCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"bid_volume_cap"`
	AskVolumeCap          cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=ask_volume_cap,json=askVolumeCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"ask_volume_cap"`
	WindowDurationSeconds int64                       `protobuf:"varint,5,opt,name=window_duration_seconds,json=windowDurationSeconds,proto3" json:"window_duration_seconds,omitempty"`
}

func (m *LiquidityTier) Reset()         { *m = LiquidityTier{} }
func (m *LiquidityTier) String() string { return proto.CompactTextString(m) }
func (*LiquidityTier) ProtoMessage()    {}
func (*LiquidityTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{2}
}
func (m *LiquidityTier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTier.Merge(m, src)
}
func (m *LiquidityTier) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTier) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTier.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTier proto.InternalMessageInfo

func (m *LiquidityTier) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LiquidityTier) GetWindowDurationSeconds() int64 {
	if m != nil {
		return m.WindowDurationSeconds
	}
	return 0
}

// OrderRewardInfo tracks reward information for individual orders
type OrderRewardInfo struct {
	OrderId           uint64                      `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	TierId            uint32                      `protobuf:"varint,2,opt,name=tier_id,json=tierId,proto3" json:"tier_id,omitempty"`
	StartTime         int64                       `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	LastUpdated       int64                       `protobuf:"varint,4,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	AccumulatedTime   int64                       `protobuf:"varint,5,opt,name=accumulated_time,json=accumulatedTime,proto3" json:"accumulated_time,omitempty"`
	TotalRewards      cosmossdk_io_math.Int       `protobuf:"bytes,6,opt,name=total_rewards,json=totalRewards,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards"`
	LastClaimedTime   int64                       `protobuf:"varint,7,opt,name=last_claimed_time,json=lastClaimedTime,proto3" json:"last_claimed_time,omitempty"`
	SpreadMultiplier  cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=spread_multiplier,json=spreadMultiplier,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"spread_multiplier"`
	VolumeCapFraction cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=volume_cap_fraction,json=volumeCapFraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"volume_cap_fraction"`
}

func (m *OrderRewardInfo) Reset()         { *m = OrderRewardInfo{} }
func (m *OrderRewardInfo) String() string { return proto.CompactTextString(m) }
func (*OrderRewardInfo) ProtoMessage()    {}
func (*OrderRewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{3}
}
func (m *OrderRewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderRewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderRewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderRewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRewardInfo.Merge(m, src)
}
func (m *OrderRewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *OrderRewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRewardInfo proto.InternalMessageInfo

func (m *OrderRewardInfo) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *OrderRewardInfo) GetTierId() uint32 {
	if m != nil {
		return m.TierId
	}
	return 0
}

func (m *OrderRewardInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *OrderRewardInfo) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *OrderRewardInfo) GetAccumulatedTime() int64 {
	if m != nil {
		return m.AccumulatedTime
	}
	return 0
}

func (m *OrderRewardInfo) GetLastClaimedTime() int64 {
	if m != nil {
		return m.LastClaimedTime
	}
	return 0
}

// VolumeTracker tracks volume for tier calculations
type VolumeTracker struct {
	PairId  uint64         `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	Windows []VolumeWindow `protobuf:"bytes,2,rep,name=windows,proto3" json:"windows"`
}

func (m *VolumeTracker) Reset()         { *m = VolumeTracker{} }
func (m *VolumeTracker) String() string { return proto.CompactTextString(m) }
func (*VolumeTracker) ProtoMessage()    {}
func (*VolumeTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{4}
}
func (m *VolumeTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeTracker.Merge(m, src)
}
func (m *VolumeTracker) XXX_Size() int {
	return m.Size()
}
func (m *VolumeTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeTracker.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeTracker proto.InternalMessageInfo

func (m *VolumeTracker) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *VolumeTracker) GetWindows() []VolumeWindow {
	if m != nil {
		return m.Windows
	}
	return nil
}

// VolumeWindow represents volume in a time window
type VolumeWindow struct {
	StartTime int64                 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	BidVolume cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=bid_volume,json=bidVolume,proto3,customtype=cosmossdk.io/math.Int" json:"bid_volume"`
	AskVolume cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=ask_volume,json=askVolume,proto3,customtype=cosmossdk.io/math.Int" json:"ask_volume"`
}

func (m *VolumeWindow) Reset()         { *m = VolumeWindow{} }
func (m *VolumeWindow) String() string { return proto.CompactTextString(m) }
func (*VolumeWindow) ProtoMessage()    {}
func (*VolumeWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{5}
}
func (m *VolumeWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeWindow.Merge(m, src)
}
func (m *VolumeWindow) XXX_Size() int {
	return m.Size()
}
func (m *VolumeWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeWindow.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeWindow proto.InternalMessageInfo

func (m *VolumeWindow) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *VolumeWindow) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// PriceReference tracks reference prices for tier calculations
type PriceReference struct {
	PairId         uint64                      `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	ReferencePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=reference_price,json=referencePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"reference_price"`
	LastUpdated    int64                       `protobuf:"varint,3,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
}

func (m *PriceReference) Reset()         { *m = PriceReference{} }
func (m *PriceReference) String() string { return proto.CompactTextString(m) }
func (*PriceReference) ProtoMessage()    {}
func (*PriceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{6}
}
func (m *PriceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceReference.Merge(m, src)
}
func (m *PriceReference) XXX_Size() int {
	return m.Size()
}
func (m *PriceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceReference.DiscardUnknown(m)
}

var xxx_messageInfo_PriceReference proto.InternalMessageInfo

func (m *PriceReference) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *PriceReference) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

// Trade represents an executed trade
type Trade struct {
	Id          uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PairId      uint64     `protobuf:"varint,2,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	BuyOrderId  uint64     `protobuf:"varint,3,opt,name=buy_order_id,json=buyOrderId,proto3" json:"buy_order_id,omitempty"`
	SellOrderId uint64     `protobuf:"varint,4,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	Buyer       string     `protobuf:"bytes,5,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Seller      string     `protobuf:"bytes,6,opt,name=seller,proto3" json:"seller,omitempty"`
	Price       types.Coin `protobuf:"bytes,7,opt,name=price,proto3" json:"price"`
	Amount      types.Coin `protobuf:"bytes,8,opt,name=amount,proto3" json:"amount"`
	ExecutedAt  int64      `protobuf:"varint,9,opt,name=executed_at,json=executedAt,proto3" json:"executed_at,omitempty"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{7}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Trade) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *Trade) GetBuyOrderId() uint64 {
	if m != nil {
		return m.BuyOrderId
	}
	return 0
}

func (m *Trade) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *Trade) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *Trade) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *Trade) GetPrice() types.Coin {
	if m != nil {
		return m.Price
	}
	return types.Coin{}
}

func (m *Trade) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *Trade) GetExecutedAt() int64 {
	if m != nil {
		return m.ExecutedAt
	}
	return 0
}

// UserReward contains user LC rewards summary
type UserReward struct {
	Address        string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	TotalRewards   cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_rewards,json=totalRewards,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards"`
	ClaimedRewards cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=claimed_rewards,json=claimedRewards,proto3,customtype=cosmossdk.io/math.Int" json:"claimed_rewards"`
}

func (m *UserReward) Reset()         { *m = UserReward{} }
func (m *UserReward) String() string { return proto.CompactTextString(m) }
func (*UserReward) ProtoMessage()    {}
func (*UserReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{8}
}
func (m *UserReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserReward.Merge(m, src)
}
func (m *UserReward) XXX_Size() int {
	return m.Size()
}
func (m *UserReward) XXX_DiscardUnknown() {
	xxx_messageInfo_UserReward.DiscardUnknown(m)
}

var xxx_messageInfo_UserReward proto.InternalMessageInfo

func (m *UserReward) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// UserRewardInfo contains user LC rewards information
type UserRewardInfo struct {
	Address      string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	PendingLc    cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=pending_lc,json=pendingLc,proto3,customtype=cosmossdk.io/math.Int" json:"pending_lc"`
	ClaimedLc    cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=claimed_lc,json=claimedLc,proto3,customtype=cosmossdk.io/math.Int" json:"claimed_lc"`
	OrderRewards []OrderRewardInfo     `protobuf:"bytes,4,rep,name=order_rewards,json=orderRewards,proto3" json:"order_rewards"`
}

func (m *UserRewardInfo) Reset()         { *m = UserRewardInfo{} }
func (m *UserRewardInfo) String() string { return proto.CompactTextString(m) }
func (*UserRewardInfo) ProtoMessage()    {}
func (*UserRewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{9}
}
func (m *UserRewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRewardInfo.Merge(m, src)
}
func (m *UserRewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserRewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserRewardInfo proto.InternalMessageInfo

func (m *UserRewardInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *UserRewardInfo) GetOrderRewards() []OrderRewardInfo {
	if m != nil {
		return m.OrderRewards
	}
	return nil
}

// DynamicRewardState tracks the current state of the dynamic reward system
type DynamicRewardState struct {
	// Current annual reward rate (between 7% and 100%)
	CurrentAnnualRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=current_annual_rate,json=currentAnnualRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_annual_rate"`
	// Last update block height
	LastUpdateBlock int64 `protobuf:"varint,2,opt,name=last_update_block,json=lastUpdateBlock,proto3" json:"last_update_block,omitempty"`
	// Last update time in unix seconds
	LastUpdateTime int64 `protobuf:"varint,3,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// Volume snapshots for historical tracking
	VolumeHistory []VolumeSnapshot `protobuf:"bytes,4,rep,name=volume_history,json=volumeHistory,proto3" json:"volume_history"`
}

func (m *DynamicRewardState) Reset()         { *m = DynamicRewardState{} }
func (m *DynamicRewardState) String() string { return proto.CompactTextString(m) }
func (*DynamicRewardState) ProtoMessage()    {}
func (*DynamicRewardState) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{10}
}
func (m *DynamicRewardState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicRewardState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicRewardState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicRewardState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicRewardState.Merge(m, src)
}
func (m *DynamicRewardState) XXX_Size() int {
	return m.Size()
}
func (m *DynamicRewardState) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicRewardState.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicRewardState proto.InternalMessageInfo

func (m *DynamicRewardState) GetLastUpdateBlock() int64 {
	if m != nil {
		return m.LastUpdateBlock
	}
	return 0
}

func (m *DynamicRewardState) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *DynamicRewardState) GetVolumeHistory() []VolumeSnapshot {
	if m != nil {
		return m.VolumeHistory
	}
	return nil
}

// VolumeSnapshot tracks trading volume at a specific point in time
type VolumeSnapshot struct {
	BlockHeight int64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Timestamp   int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Trading volume in the last hour
	HourlyVolume cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=hourly_volume,json=hourlyVolume,proto3,customtype=cosmossdk.io/math.Int" json:"hourly_volume"`
	// Current liquidity depth (total value in order books)
	LiquidityDepth cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=liquidity_depth,json=liquidityDepth,proto3,customtype=cosmossdk.io/math.Int" json:"liquidity_depth"`
}

func (m *VolumeSnapshot) Reset()         { *m = VolumeSnapshot{} }
func (m *VolumeSnapshot) String() string { return proto.CompactTextString(m) }
func (*VolumeSnapshot) ProtoMessage()    {}
func (*VolumeSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{11}
}
func (m *VolumeSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeSnapshot.Merge(m, src)
}
func (m *VolumeSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *VolumeSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeSnapshot proto.InternalMessageInfo

func (m *VolumeSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *VolumeSnapshot) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// FeeEstimate provides fee calculation details for an order
type FeeEstimate struct {
	OrderValue          cosmossdk_io_math.Int       `protobuf:"bytes,1,opt,name=order_value,json=orderValue,proto3,customtype=cosmossdk.io/math.Int" json:"order_value"`
	MakerFee            cosmossdk_io_math.Int       `protobuf:"bytes,2,opt,name=maker_fee,json=makerFee,proto3,customtype=cosmossdk.io/math.Int" json:"maker_fee"`
	TakerFee            cosmossdk_io_math.Int       `protobuf:"bytes,3,opt,name=taker_fee,json=takerFee,proto3,customtype=cosmossdk.io/math.Int" json:"taker_fee"`
	SellFee             cosmossdk_io_math.Int       `protobuf:"bytes,4,opt,name=sell_fee,json=sellFee,proto3,customtype=cosmossdk.io/math.Int" json:"sell_fee"`
	LiquidityMultiplier cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=liquidity_multiplier,json=liquidityMultiplier,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"liquidity_multiplier"`
	AvailableLiquidity  cosmossdk_io_math.Int       `protobuf:"bytes,6,opt,name=available_liquidity,json=availableLiquidity,proto3,customtype=cosmossdk.io/math.Int" json:"available_liquidity"`
	MarketImpact        cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=market_impact,json=marketImpact,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"market_impact"`
}

func (m *FeeEstimate) Reset()         { *m = FeeEstimate{} }
func (m *FeeEstimate) String() string { return proto.CompactTextString(m) }
func (*FeeEstimate) ProtoMessage()    {}
func (*FeeEstimate) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{12}
}
func (m *FeeEstimate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeEstimate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeEstimate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeEstimate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeEstimate.Merge(m, src)
}
func (m *FeeEstimate) XXX_Size() int {
	return m.Size()
}
func (m *FeeEstimate) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeEstimate.DiscardUnknown(m)
}

var xxx_messageInfo_FeeEstimate proto.InternalMessageInfo

// OrderBookDepth provides liquidity depth information
type OrderBookDepth struct {
	PairId uint64        `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	Bids   []*PriceLevel `protobuf:"bytes,2,rep,name=bids,proto3" json:"bids,omitempty"`
	Asks   []*PriceLevel `protobuf:"bytes,3,rep,name=asks,proto3" json:"asks,omitempty"`
}

func (m *OrderBookDepth) Reset()         { *m = OrderBookDepth{} }
func (m *OrderBookDepth) String() string { return proto.CompactTextString(m) }
func (*OrderBookDepth) ProtoMessage()    {}
func (*OrderBookDepth) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{13}
}
func (m *OrderBookDepth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookDepth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookDepth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBookDepth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookDepth.Merge(m, src)
}
func (m *OrderBookDepth) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookDepth) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookDepth.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookDepth proto.InternalMessageInfo

func (m *OrderBookDepth) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *OrderBookDepth) GetBids() []*PriceLevel {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookDepth) GetAsks() []*PriceLevel {
	if m != nil {
		return m.Asks
	}
	return nil
}

// PriceLevel represents liquidity at a specific price
type PriceLevel struct {
	Price  cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	Amount cosmossdk_io_math.Int       `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *PriceLevel) Reset()         { *m = PriceLevel{} }
func (m *PriceLevel) String() string { return proto.CompactTextString(m) }
func (*PriceLevel) ProtoMessage()    {}
func (*PriceLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{14}
}
func (m *PriceLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceLevel.Merge(m, src)
}
func (m *PriceLevel) XXX_Size() int {
	return m.Size()
}
func (m *PriceLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceLevel.DiscardUnknown(m)
}

var xxx_messageInfo_PriceLevel proto.InternalMessageInfo

// MarketDepthAnalysis provides liquidity analysis at different order sizes
type MarketDepthAnalysis struct {
	PairId      uint64           `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	IsBuyOrder  bool             `protobuf:"varint,2,opt,name=is_buy_order,json=isBuyOrder,proto3" json:"is_buy_order,omitempty"`
	PriceLevels []LiquidityLevel `protobuf:"bytes,3,rep,name=price_levels,json=priceLevels,proto3" json:"price_levels"`
}

func (m *MarketDepthAnalysis) Reset()         { *m = MarketDepthAnalysis{} }
func (m *MarketDepthAnalysis) String() string { return proto.CompactTextString(m) }
func (*MarketDepthAnalysis) ProtoMessage()    {}
func (*MarketDepthAnalysis) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{15}
}
func (m *MarketDepthAnalysis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketDepthAnalysis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketDepthAnalysis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketDepthAnalysis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketDepthAnalysis.Merge(m, src)
}
func (m *MarketDepthAnalysis) XXX_Size() int {
	return m.Size()
}
func (m *MarketDepthAnalysis) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketDepthAnalysis.DiscardUnknown(m)
}

var xxx_messageInfo_MarketDepthAnalysis proto.InternalMessageInfo

func (m *MarketDepthAnalysis) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *MarketDepthAnalysis) GetIsBuyOrder() bool {
	if m != nil {
		return m.IsBuyOrder
	}
	return false
}

func (m *MarketDepthAnalysis) GetPriceLevels() []LiquidityLevel {
	if m != nil {
		return m.PriceLevels
	}
	return nil
}

// LiquidityLevel represents liquidity impact at different order sizes
type LiquidityLevel struct {
	OrderSize           cosmossdk_io_math.Int       `protobuf:"bytes,1,opt,name=order_size,json=orderSize,proto3,customtype=cosmossdk.io/math.Int" json:"order_size"`
	AvailableLiquidity  cosmossdk_io_math.Int       `protobuf:"bytes,2,opt,name=available_liquidity,json=availableLiquidity,proto3,customtype=cosmossdk.io/math.Int" json:"available_liquidity"`
	LiquidityMultiplier cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=liquidity_multiplier,json=liquidityMultiplier,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"liquidity_multiplier"`
	EffectiveFeeRate    cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=effective_fee_rate,json=effectiveFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"effective_fee_rate"`
}

func (m *LiquidityLevel) Reset()         { *m = LiquidityLevel{} }
func (m *LiquidityLevel) String() string { return proto.CompactTextString(m) }
func (*LiquidityLevel) ProtoMessage()    {}
func (*LiquidityLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{16}
}
func (m *LiquidityLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityLevel.Merge(m, src)
}
func (m *LiquidityLevel) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityLevel proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Order)(nil), "mychain.dex.v1.Order")
	proto.RegisterType((*TradingPair)(nil), "mychain.dex.v1.TradingPair")
	proto.RegisterType((*LiquidityTier)(nil), "mychain.dex.v1.LiquidityTier")
	proto.RegisterType((*OrderRewardInfo)(nil), "mychain.dex.v1.OrderRewardInfo")
	proto.RegisterType((*VolumeTracker)(nil), "mychain.dex.v1.VolumeTracker")
	proto.RegisterType((*VolumeWindow)(nil), "mychain.dex.v1.VolumeWindow")
	proto.RegisterType((*PriceReference)(nil), "mychain.dex.v1.PriceReference")
	proto.RegisterType((*Trade)(nil), "mychain.dex.v1.Trade")
	proto.RegisterType((*UserReward)(nil), "mychain.dex.v1.UserReward")
	proto.RegisterType((*UserRewardInfo)(nil), "mychain.dex.v1.UserRewardInfo")
	proto.RegisterType((*DynamicRewardState)(nil), "mychain.dex.v1.DynamicRewardState")
	proto.RegisterType((*VolumeSnapshot)(nil), "mychain.dex.v1.VolumeSnapshot")
	proto.RegisterType((*FeeEstimate)(nil), "mychain.dex.v1.FeeEstimate")
	proto.RegisterType((*OrderBookDepth)(nil), "mychain.dex.v1.OrderBookDepth")
	proto.RegisterType((*PriceLevel)(nil), "mychain.dex.v1.PriceLevel")
	proto.RegisterType((*MarketDepthAnalysis)(nil), "mychain.dex.v1.MarketDepthAnalysis")
	proto.RegisterType((*LiquidityLevel)(nil), "mychain.dex.v1.LiquidityLevel")
}

func init() { proto.RegisterFile("mychain/dex/v1/types.proto", fileDescriptor_365ac4383fac3c97) }

var fileDescriptor_365ac4383fac3c97 = []byte{
	// 1552 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0xd6, 0x90, 0xa2, 0x48, 0x16, 0x7f, 0x24, 0x8f, 0xe4, 0x98, 0x56, 0x6c, 0x8a, 0x99, 0x5c,
	0x94, 0x00, 0x21, 0x21, 0x07, 0xce, 0x1f, 0x8c, 0x00, 0xa2, 0x15, 0xc5, 0x4a, 0xe4, 0xd8, 0x19,
	0xc9, 0x0e, 0x90, 0xcb, 0xa0, 0x39, 0xd3, 0x14, 0x1b, 0x9c, 0x1f, 0x7a, 0xba, 0x87, 0x16, 0x7d,
	0xc8, 0x3d, 0x40, 0x0e, 0xb9, 0x26, 0x8f, 0xb1, 0xc0, 0x9e, 0xf6, 0xba, 0x07, 0xfb, 0xe6, 0xbd,
	0x2d, 0x16, 0x58, 0x63, 0x61, 0x3f, 0xc1, 0xee, 0x13, 0x2c, 0xba, 0xba, 0x67, 0x48, 0x49, 0x2b,
	0x68, 0xe4, 0xbd, 0xb1, 0xab, 0xea, 0xab, 0xae, 0xa9, 0xae, 0xfa, 0xaa, 0x9b, 0xb0, 0x19, 0xcc,
	0xdc, 0x11, 0x61, 0x61, 0xcf, 0xa3, 0xa7, 0xbd, 0xe9, 0x4e, 0x4f, 0xcc, 0x26, 0x94, 0x77, 0x27,
	0x71, 0x24, 0x22, 0xb3, 0xa9, 0x75, 0x5d, 0x8f, 0x9e, 0x76, 0xa7, 0x3b, 0x9b, 0x1b, 0x27, 0xd1,
	0x49, 0x84, 0xaa, 0x9e, 0xfc, 0xa5, 0xac, 0x36, 0xdb, 0x6e, 0xc4, 0x83, 0x88, 0xf7, 0x06, 0x84,
	0xd3, 0xde, 0x74, 0x67, 0x40, 0x05, 0xd9, 0xe9, 0xb9, 0x11, 0x0b, 0x95, 0xde, 0xfa, 0xa2, 0x00,
	0xa5, 0x27, 0xb1, 0x47, 0x63, 0xb3, 0x09, 0x05, 0xe6, 0xb5, 0x8c, 0x8e, 0xb1, 0xbd, 0x6c, 0x17,
	0x98, 0x67, 0x6e, 0x40, 0x29, 0x20, 0x63, 0x1a, 0xb7, 0x0a, 0x1d, 0x63, 0xbb, 0x6a, 0xab, 0x85,
	0x79, 0x0b, 0xca, 0x13, 0xc2, 0x62, 0x87, 0x79, 0xad, 0x22, 0x9a, 0xae, 0xc8, 0xe5, 0x81, 0x67,
	0xde, 0x84, 0x15, 0xc6, 0x9d, 0x41, 0x32, 0x6b, 0x2d, 0x77, 0x8c, 0xed, 0x8a, 0x5d, 0x62, 0xbc,
	0x9f, 0xcc, 0xcc, 0xfb, 0x50, 0x9a, 0xc4, 0xcc, 0xa5, 0xad, 0x52, 0xc7, 0xd8, 0xae, 0xdd, 0xbb,
	0xdd, 0x55, 0xf1, 0x74, 0x65, 0x3c, 0x5d, 0x1d, 0x4f, 0xf7, 0x61, 0xc4, 0xc2, 0xfe, 0xf2, 0xeb,
	0x77, 0x5b, 0x4b, 0xb6, 0xb2, 0x36, 0x7f, 0x0b, 0x2b, 0x24, 0x88, 0x92, 0x50, 0xb4, 0x56, 0xf2,
	0xe1, 0xb4, 0xb9, 0xb9, 0x07, 0x8d, 0x21, 0xf3, 0x7d, 0xea, 0x39, 0x1a, 0x5f, 0xce, 0x87, 0xaf,
	0x2b, 0xd4, 0xae, 0xf2, 0x72, 0x17, 0xc0, 0x8d, 0x29, 0x11, 0xd2, 0x8d, 0x68, 0x55, 0x3a, 0xc6,
	0x76, 0xd1, 0xae, 0x6a, 0xc9, 0x2e, 0xaa, 0x93, 0x89, 0x97, 0xaa, 0xab, 0x4a, 0xad, 0x25, 0xbb,
	0xc2, 0x4a, 0xa0, 0x76, 0x1c, 0x13, 0x8f, 0x85, 0x27, 0x4f, 0x09, 0xbb, 0x98, 0xd8, 0xbb, 0x00,
	0x32, 0x0a, 0xc7, 0xa3, 0x61, 0x14, 0xe8, 0xec, 0x56, 0xa5, 0x64, 0x4f, 0x0a, 0xcc, 0x2d, 0xa8,
	0xbd, 0x48, 0x22, 0x91, 0xea, 0x8b, 0xa8, 0x07, 0x14, 0x29, 0x83, 0x9f, 0xc0, 0x0a, 0x71, 0x05,
	0x9b, 0x52, 0x9d, 0x69, 0xbd, 0xb2, 0x3e, 0x2b, 0x40, 0xe3, 0x90, 0xbd, 0x48, 0x98, 0xc7, 0xc4,
	0xec, 0x98, 0x9d, 0x39, 0xd2, 0x06, 0xee, 0x7c, 0x08, 0xab, 0x98, 0x5e, 0xc7, 0xa3, 0x53, 0x46,
	0x04, 0x8b, 0x42, 0xb5, 0x7d, 0xff, 0xe7, 0x32, 0x07, 0x5f, 0xbd, 0xdb, 0xfa, 0xa9, 0xca, 0x12,
	0xf7, 0xc6, 0x5d, 0x16, 0xf5, 0x02, 0x22, 0x46, 0xdd, 0x43, 0x7a, 0x42, 0xdc, 0xd9, 0x1e, 0x75,
	0xed, 0x26, 0x62, 0xf7, 0x52, 0xa8, 0x79, 0x00, 0xcd, 0x01, 0xf3, 0x9c, 0x69, 0xe4, 0x27, 0x01,
	0x75, 0x5c, 0x32, 0x51, 0xb1, 0xe6, 0x73, 0x56, 0x1f, 0x30, 0xef, 0x39, 0x22, 0x1f, 0x92, 0x89,
	0x74, 0x45, 0xf8, 0x78, 0xd1, 0xd5, 0xf2, 0x35, 0x5c, 0x11, 0x3e, 0x9e, 0xbb, 0xfa, 0x0d, 0xdc,
	0x7a, 0xc9, 0x42, 0x2f, 0x7a, 0xe9, 0x78, 0x49, 0x8c, 0x81, 0x3a, 0x9c, 0xba, 0x51, 0xe8, 0x71,
	0x2c, 0xc1, 0xa2, 0x7d, 0x53, 0xa9, 0xf7, 0xb4, 0xf6, 0x48, 0x29, 0xad, 0x37, 0x45, 0x58, 0xc5,
	0x46, 0xb0, 0xe9, 0x4b, 0x12, 0x7b, 0x07, 0xe1, 0x30, 0x32, 0x6f, 0x43, 0x25, 0x92, 0x22, 0x27,
	0x3b, 0xbf, 0x32, 0xae, 0x0f, 0x3c, 0xd9, 0x07, 0x82, 0x29, 0x4d, 0x01, 0xf3, 0xbb, 0x22, 0x97,
	0x07, 0x78, 0xba, 0x5c, 0x90, 0x58, 0x38, 0x82, 0x05, 0x14, 0x33, 0x52, 0xb4, 0xab, 0x28, 0x39,
	0x66, 0x01, 0x35, 0x7f, 0x06, 0x75, 0x9f, 0x70, 0xe1, 0xe8, 0x6a, 0xc1, 0xef, 0x2c, 0xda, 0x35,
	0x29, 0x7b, 0xa6, 0x44, 0xe6, 0x2f, 0x60, 0x8d, 0xb8, 0x6e, 0x12, 0x24, 0x3e, 0x56, 0x18, 0xfa,
	0x51, 0xa1, 0xaf, 0x2e, 0xc8, 0xd1, 0x5b, 0x1f, 0x1a, 0x22, 0x12, 0xc4, 0x77, 0x62, 0x0c, 0x9a,
	0x63, 0xb7, 0x54, 0xfb, 0x77, 0x75, 0xda, 0x6e, 0x5e, 0x4c, 0xdb, 0x41, 0x28, 0xec, 0x3a, 0x62,
	0xd4, 0x77, 0x72, 0xf3, 0x97, 0x70, 0x03, 0x23, 0x72, 0x7d, 0xc2, 0x82, 0x74, 0xbf, 0xb2, 0xda,
	0x4f, 0x2a, 0x1e, 0x2a, 0x39, 0xee, 0xf7, 0x14, 0x6e, 0xf0, 0x49, 0x4c, 0x89, 0xe7, 0x04, 0x89,
	0x2f, 0xd8, 0xc4, 0x67, 0x34, 0xc6, 0xf6, 0xc8, 0x79, 0x54, 0x6b, 0x0a, 0xfd, 0x38, 0x03, 0x9b,
	0x47, 0xb0, 0x3e, 0x3f, 0x75, 0x67, 0x18, 0xcb, 0x5a, 0x8e, 0x42, 0xec, 0xa9, 0x9c, 0x3e, 0x6f,
	0x4c, 0xd3, 0xb3, 0xdf, 0xd7, 0x68, 0x6b, 0x08, 0x0d, 0x55, 0x10, 0xc7, 0x31, 0x71, 0xcf, 0xb1,
	0x96, 0x71, 0x86, 0xb5, 0x1e, 0x40, 0x59, 0x95, 0x03, 0x6f, 0x15, 0x3a, 0xc5, 0xed, 0xda, 0xbd,
	0x3b, 0xdd, 0xb3, 0xb4, 0xda, 0x55, 0x8e, 0xfe, 0x81, 0x46, 0x9a, 0x2b, 0x52, 0x88, 0xf5, 0xb9,
	0x01, 0xf5, 0x45, 0xfd, 0xb9, 0xc3, 0x37, 0xce, 0x1f, 0xfe, 0x6d, 0xa8, 0xd0, 0x50, 0x67, 0xb8,
	0x80, 0xca, 0x32, 0x0d, 0x55, 0x66, 0x1f, 0x00, 0xcc, 0x9b, 0x49, 0x37, 0xd2, 0x15, 0xc7, 0x58,
	0xcd, 0x5a, 0x48, 0xa2, 0xe7, 0xfd, 0xa3, 0x7b, 0xe7, 0x2a, 0x74, 0xd6, 0x35, 0xd6, 0xff, 0x0d,
	0x68, 0x3e, 0x95, 0xbd, 0x6d, 0xd3, 0x21, 0x8d, 0x69, 0xe8, 0xd2, 0xcb, 0x13, 0x76, 0x08, 0xab,
	0x71, 0x6a, 0xe5, 0x28, 0x66, 0xbf, 0x0e, 0x85, 0x64, 0x58, 0xdc, 0xef, 0x42, 0x37, 0x14, 0x2f,
	0x74, 0x83, 0xf5, 0x69, 0x01, 0x4a, 0x92, 0x4d, 0xe9, 0x05, 0x1e, 0x5d, 0x88, 0xb1, 0x70, 0x26,
	0xc6, 0x0e, 0xd4, 0x07, 0xc9, 0xcc, 0xc9, 0x5a, 0x57, 0x0d, 0x2a, 0x18, 0x24, 0xb3, 0x27, 0xba,
	0x7b, 0x2d, 0x68, 0x70, 0xea, 0xfb, 0x73, 0x93, 0x65, 0x34, 0xa9, 0x49, 0x61, 0x6a, 0xb3, 0x01,
	0xa5, 0x41, 0x32, 0xa3, 0x31, 0xf6, 0x5e, 0xd5, 0x56, 0x0b, 0x49, 0xbe, 0xd2, 0x88, 0xc6, 0xaa,
	0xd5, 0x6c, 0xbd, 0x9a, 0xcf, 0xb9, 0xf2, 0x47, 0xce, 0xb9, 0xca, 0xf5, 0xe6, 0xdc, 0x16, 0xd4,
	0xe8, 0x29, 0x75, 0x93, 0x33, 0x33, 0x08, 0x52, 0xd1, 0xae, 0xb0, 0x3e, 0x31, 0x00, 0x9e, 0xf1,
	0x94, 0xce, 0xcc, 0x16, 0x94, 0x89, 0xe7, 0xc5, 0x94, 0x73, 0xcc, 0x60, 0xd5, 0x4e, 0x97, 0x17,
	0x39, 0xa4, 0x70, 0x7d, 0x0e, 0xd9, 0x87, 0xd5, 0x94, 0x3e, 0x52, 0x2f, 0xb9, 0x4a, 0xb8, 0xa9,
	0x51, 0xda, 0x8f, 0xf5, 0x9d, 0x01, 0xcd, 0x79, 0xd0, 0xc8, 0xc1, 0x97, 0x07, 0xfe, 0x00, 0x60,
	0x42, 0x43, 0x39, 0x66, 0x1d, 0xdf, 0xcd, 0x17, 0x75, 0x55, 0x03, 0x0e, 0x5d, 0x89, 0x4e, 0x43,
	0xf6, 0xdd, 0x9c, 0x0d, 0xa7, 0x01, 0x87, 0xae, 0xf9, 0x17, 0x68, 0xa8, 0xda, 0x49, 0x3f, 0x77,
	0x19, 0xd9, 0x63, 0xeb, 0x3c, 0x7b, 0x9c, 0x9b, 0x28, 0xe9, 0x65, 0x23, 0x9a, 0x8b, 0xb9, 0xf5,
	0x9f, 0x02, 0x98, 0x7b, 0xb3, 0x90, 0x04, 0xcc, 0x55, 0xa2, 0x23, 0x41, 0x04, 0x95, 0xcc, 0xe8,
	0x26, 0x71, 0x4c, 0x43, 0xe1, 0x90, 0x30, 0x4c, 0xe4, 0x01, 0x11, 0xa1, 0x48, 0x25, 0x2f, 0x33,
	0x6a, 0xfc, 0x2e, 0xc2, 0x6d, 0xe9, 0x34, 0x25, 0x7b, 0xd5, 0x70, 0xce, 0xc0, 0x8f, 0xdc, 0xb1,
	0xa6, 0xa2, 0xd5, 0x79, 0xd7, 0xf5, 0xa5, 0xd8, 0xdc, 0x86, 0xb5, 0x45, 0xdb, 0x85, 0x79, 0xd6,
	0x9c, 0x9b, 0x22, 0x79, 0xfd, 0x15, 0x9a, 0x9a, 0xc4, 0x47, 0x8c, 0x8b, 0x28, 0x9e, 0xe9, 0x74,
	0xb4, 0x7f, 0x98, 0x4c, 0x8f, 0x42, 0x32, 0xe1, 0xa3, 0x48, 0xe8, 0x6c, 0x34, 0x14, 0xf6, 0x91,
	0x82, 0x5a, 0x5f, 0x1b, 0xd0, 0x3c, 0x6b, 0x27, 0x69, 0x02, 0x23, 0x75, 0x46, 0x94, 0x9d, 0x8c,
	0x84, 0x26, 0xd6, 0x1a, 0xca, 0x1e, 0xa1, 0xc8, 0xbc, 0x03, 0x55, 0x19, 0x20, 0x17, 0x24, 0x98,
	0xe8, 0x0f, 0x9a, 0x0b, 0x64, 0x8d, 0x8f, 0xa2, 0x24, 0xf6, 0x67, 0xd7, 0x22, 0xd8, 0xba, 0xc2,
	0x68, 0x8e, 0xdd, 0x87, 0x55, 0x3f, 0xbd, 0x5d, 0x39, 0x1e, 0x9d, 0x88, 0x51, 0x3e, 0xa2, 0x6d,
	0x66, 0xa8, 0x3d, 0x09, 0xb2, 0xbe, 0x2d, 0x42, 0x6d, 0x9f, 0xd2, 0x3f, 0x71, 0xc1, 0x02, 0x79,
	0x24, 0x7f, 0x84, 0x9a, 0x2a, 0xa5, 0x29, 0xf1, 0x93, 0xf4, 0x7c, 0xaf, 0xf0, 0x09, 0x88, 0x78,
	0x2e, 0x01, 0xe6, 0x1f, 0xa0, 0x8a, 0x57, 0x73, 0x67, 0x48, 0x69, 0xbe, 0x2e, 0xa8, 0xa0, 0xfd,
	0x3e, 0x45, 0xac, 0xc8, 0xb0, 0xb9, 0x72, 0x52, 0x11, 0x29, 0xf6, 0x77, 0x50, 0x41, 0x0e, 0x95,
	0xd0, 0x5c, 0x89, 0x28, 0x4b, 0x73, 0x89, 0x7c, 0x0e, 0x1b, 0xf3, 0x4c, 0x2e, 0x5c, 0x24, 0x4a,
	0xf9, 0x4b, 0x7b, 0x3d, 0x73, 0xb0, 0x70, 0x97, 0xf8, 0x1b, 0xac, 0x93, 0x29, 0x61, 0x3e, 0x19,
	0xf8, 0xd4, 0xc9, 0x0c, 0xf2, 0xdd, 0x89, 0xcc, 0x0c, 0x99, 0x5d, 0xa1, 0xcd, 0x47, 0xd0, 0x08,
	0x48, 0x3c, 0xa6, 0xc2, 0x61, 0xc1, 0x84, 0xb8, 0xea, 0x2d, 0x91, 0xf7, 0x52, 0xaa, 0x90, 0x07,
	0x08, 0xb4, 0xfe, 0x6d, 0x40, 0x13, 0xa9, 0xa0, 0x1f, 0x45, 0x63, 0x2c, 0x83, 0xcb, 0x27, 0x6c,
	0x17, 0x96, 0x07, 0xcc, 0x4b, 0xef, 0x23, 0x9b, 0xe7, 0x5b, 0x08, 0x07, 0xe7, 0x21, 0x9d, 0x52,
	0xdf, 0x46, 0x3b, 0x69, 0x4f, 0xf8, 0x58, 0x12, 0xee, 0x95, 0xf6, 0xd2, 0xce, 0xfa, 0x17, 0xc0,
	0x5c, 0x66, 0xfe, 0x3e, 0x9d, 0x5b, 0xd7, 0xe0, 0x15, 0x3d, 0xbb, 0xee, 0x67, 0xb3, 0x2b, 0x57,
	0xd5, 0x69, 0x63, 0xeb, 0x7f, 0x06, 0xac, 0x3f, 0xc6, 0xe4, 0x60, 0x22, 0x76, 0x43, 0xe2, 0xcf,
	0x38, 0xe3, 0x97, 0x27, 0xa4, 0x03, 0x75, 0xf5, 0xb2, 0x54, 0xe3, 0x1a, 0x77, 0xab, 0xd8, 0x80,
	0xef, 0x4b, 0xf5, 0x74, 0xfd, 0x33, 0xd4, 0xd5, 0xbb, 0xc6, 0x97, 0xdf, 0x94, 0xa6, 0xe2, 0x02,
	0xfb, 0x64, 0x27, 0x8b, 0x9f, 0xae, 0xd9, 0xa7, 0x36, 0xc9, 0x92, 0xc1, 0xad, 0x37, 0x05, 0x68,
	0x9e, 0xb5, 0x92, 0x73, 0x42, 0xb5, 0x27, 0x67, 0xaf, 0x72, 0x76, 0x67, 0x15, 0x01, 0x47, 0xec,
	0x15, 0xbd, 0xac, 0x24, 0x0b, 0x1f, 0x5b, 0x92, 0x97, 0xb5, 0x4e, 0xf1, 0x47, 0xb6, 0xce, 0xdf,
	0xc1, 0xa4, 0xc3, 0x21, 0xc5, 0x87, 0xa4, 0xec, 0x68, 0x35, 0x6b, 0xae, 0xf1, 0x08, 0x5b, 0xcb,
	0xe0, 0xfb, 0x94, 0xca, 0x51, 0xd3, 0xff, 0xd5, 0xeb, 0xf7, 0x6d, 0xe3, 0xed, 0xfb, 0xb6, 0xf1,
	0xcd, 0xfb, 0xb6, 0xf1, 0xdf, 0x0f, 0xed, 0xa5, 0xb7, 0x1f, 0xda, 0x4b, 0x5f, 0x7e, 0x68, 0x2f,
	0xfd, 0x73, 0x3d, 0xfd, 0x57, 0xe3, 0x14, 0xff, 0xd7, 0xc0, 0x3f, 0x35, 0x06, 0x2b, 0xf8, 0x7f,
	0xc4, 0xaf, 0xbf, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x51, 0x67, 0x52, 0x05, 0xf3, 0x10, 0x00, 0x00,
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.FilledAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Maker) > 0 {
		i -= len(m.Maker)
		copy(dAtA[i:], m.Maker)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Maker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowDurationSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WindowDurationSeconds))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AskVolumeCap.Size()
		i -= size
		if _, err := m.AskVolumeCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidVolumeCap.Size()
		i -= size
		if _, err := m.BidVolumeCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PriceDeviation.Size()
		i -= size
		if _, err := m.PriceDeviation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderRewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderRewardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderRewardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.VolumeCapFraction.Size()
		i -= size
		if _, err := m.VolumeCapFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.SpreadMultiplier.Size()
		i -= size
		if _, err := m.SpreadMultiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.LastClaimedTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastClaimedTime))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.TotalRewards.Size()
		i -= size
		if _, err := m.TotalRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.AccumulatedTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AccumulatedTime))
		i--
		dAtA[i] = 0x28
	}
	if m.LastUpdated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.TierId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TierId))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VolumeTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Windows) > 0 {
		for iNdEx := len(m.Windows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Windows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VolumeWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AskVolume.Size()
		i -= size
		if _, err := m.AskVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidVolume.Size()
		i -= size
		if _, err := m.BidVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EndTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ReferencePrice.Size()
		i -= size
		if _, err := m.ReferencePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExecutedAt))
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SellOrderId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x20
	}
	if m.BuyOrderId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BuyOrderId))
		i--
		dAtA[i] = 0x18
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ClaimedRewards.Size()
		i -= size
		if _, err := m.ClaimedRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalRewards.Size()
		i -= size
		if _, err := m.TotalRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRewardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRewardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderRewards) > 0 {
		for iNdEx := len(m.OrderRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.ClaimedLc.Size()
		i -= size
		if _, err := m.ClaimedLc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PendingLc.Size()
		i -= size
		if _, err := m.PendingLc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DynamicRewardState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicRewardState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicRewardState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VolumeHistory) > 0 {
		for iNdEx := len(m.VolumeHistory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VolumeHistory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x18
	}
	if m.LastUpdateBlock != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdateBlock))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.CurrentAnnualRate.Size()
		i -= size
		if _, err := m.CurrentAnnualRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VolumeSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LiquidityDepth.Size()
		i -= size
		if _, err := m.LiquidityDepth.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.HourlyVolume.Size()
		i -= size
		if _, err := m.HourlyVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Timestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeEstimate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeEstimate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeEstimate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MarketImpact.Size()
		i -= size
		if _, err := m.MarketImpact.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.AvailableLiquidity.Size()
		i -= size
		if _, err := m.AvailableLiquidity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityMultiplier.Size()
		i -= size
		if _, err := m.LiquidityMultiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.SellFee.Size()
		i -= size
		if _, err := m.SellFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TakerFee.Size()
		i -= size
		if _, err := m.TakerFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MakerFee.Size()
		i -= size
		if _, err := m.MakerFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OrderValue.Size()
		i -= size
		if _, err := m.OrderValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderBookDepth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookDepth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBookDepth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Asks) > 0 {
		for iNdEx := len(m.Asks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Asks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Bids) > 0 {
		for iNdEx := len(m.Bids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MarketDepthAnalysis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketDepthAnalysis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketDepthAnalysis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PriceLevels) > 0 {
		for iNdEx := len(m.PriceLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PriceLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsBuyOrder {
		i--
		if m.IsBuyOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EffectiveFeeRate.Size()
		i -= size
		if _, err := m.EffectiveFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.LiquidityMultiplier.Size()
		i -= size
		if _, err := m.LiquidityMultiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AvailableLiquidity.Size()
		i -= size
		if _, err := m.AvailableLiquidity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OrderSize.Size()
		i -= size
		if _, err := m.OrderSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.Maker)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if m.IsBuy {
		n += 2
	}
	l = m.Price.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.FilledAmount.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.UpdatedAt))
	}
	return n
}

func (m *TradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *LiquidityTier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = m.PriceDeviation.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.BidVolumeCap.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AskVolumeCap.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.WindowDurationSeconds != 0 {
		n += 1 + sovTypes(uint64(m.WindowDurationSeconds))
	}
	return n
}

func (m *OrderRewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovTypes(uint64(m.OrderId))
	}
	if m.TierId != 0 {
		n += 1 + sovTypes(uint64(m.TierId))
	}
	if m.StartTime != 0 {
		n += 1 + sovTypes(uint64(m.StartTime))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdated))
	}
	if m.AccumulatedTime != 0 {
		n += 1 + sovTypes(uint64(m.AccumulatedTime))
	}
	l = m.TotalRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastClaimedTime != 0 {
		n += 1 + sovTypes(uint64(m.LastClaimedTime))
	}
	l = m.SpreadMultiplier.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.VolumeCapFraction.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *VolumeTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if len(m.Windows) > 0 {
		for _, e := range m.Windows {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VolumeWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovTypes(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovTypes(uint64(m.EndTime))
	}
	l = m.BidVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AskVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *PriceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	l = m.ReferencePrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastUpdated != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdated))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if m.BuyOrderId != 0 {
		n += 1 + sovTypes(uint64(m.BuyOrderId))
	}
	if m.SellOrderId != 0 {
		n += 1 + sovTypes(uint64(m.SellOrderId))
	}
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ExecutedAt != 0 {
		n += 1 + sovTypes(uint64(m.ExecutedAt))
	}
	return n
}

func (m *UserReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.TotalRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ClaimedRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *UserRewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.PendingLc.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ClaimedLc.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.OrderRewards) > 0 {
		for _, e := range m.OrderRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DynamicRewardState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CurrentAnnualRate.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastUpdateBlock != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdateBlock))
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdateTime))
	}
	if len(m.VolumeHistory) > 0 {
		for _, e := range m.VolumeHistory {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VolumeSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTypes(uint64(m.Timestamp))
	}
	l = m.HourlyVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.LiquidityDepth.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *FeeEstimate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderValue.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.MakerFee.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.TakerFee.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.SellFee.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.LiquidityMultiplier.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AvailableLiquidity.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.MarketImpact.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *OrderBookDepth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Asks) > 0 {
		for _, e := range m.Asks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PriceLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Price.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *MarketDepthAnalysis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if m.IsBuyOrder {
		n += 2
	}
	if len(m.PriceLevels) > 0 {
		for _, e := range m.PriceLevels {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LiquidityLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderSize.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AvailableLiquidity.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.LiquidityMultiplier.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.EffectiveFeeRate.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FilledAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDeviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PriceDeviation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidVolumeCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidVolumeCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskVolumeCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskVolumeCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowDurationSeconds", wireType)
			}
			m.WindowDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderRewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderRewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderRewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TierId", wireType)
			}
			m.TierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TierId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedTime", wireType)
			}
			m.AccumulatedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumulatedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClaimedTime", wireType)
			}
			m.LastClaimedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastClaimedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpreadMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpreadMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VolumeCapFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Windows = append(m.Windows, VolumeWindow{})
			if err := m.Windows[len(m.Windows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReferencePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyOrderId", wireType)
			}
			m.BuyOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAt", wireType)
			}
			m.ExecutedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClaimedRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingLc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PendingLc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedLc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClaimedLc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderRewards = append(m.OrderRewards, OrderRewardInfo{})
			if err := m.OrderRewards[len(m.OrderRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicRewardState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicRewardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicRewardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentAnnualRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentAnnualRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateBlock", wireType)
			}
			m.LastUpdateBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeHistory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeHistory = append(m.VolumeHistory, VolumeSnapshot{})
			if err := m.VolumeHistory[len(m.VolumeHistory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HourlyVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityDepth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityDepth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeEstimate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeEstimate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeEstimate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SellFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableLiquidity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketImpact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarketImpact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookDepth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookDepth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookDepth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &PriceLevel{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asks = append(m.Asks, &PriceLevel{})
			if err := m.Asks[len(m.Asks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketDepthAnalysis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketDepthAnalysis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketDepthAnalysis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuyOrder = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceLevels = append(m.PriceLevels, LiquidityLevel{})
			if err := m.PriceLevels[len(m.PriceLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableLiquidity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EffectiveFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
