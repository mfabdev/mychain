package keeper

import (
	"context"
	"fmt"

	"mychain/x/dex/types"

	"cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

// DistributeLiquidityRewardsWithDynamicRate distributes LC rewards to ALL liquidity providers
func (k Keeper) DistributeLiquidityRewardsWithDynamicRate(ctx context.Context) error {
	sdkCtx := sdk.UnwrapSDKContext(ctx)
	height := sdkCtx.BlockHeight()
	
	// Check if it's time to distribute (every 100 blocks)
	if height%BlocksPerHour != 0 {
		return nil
	}
	
	k.Logger(ctx).Info("Distributing tier-based liquidity rewards with dynamic rate", "height", height)
	
	// Calculate dynamic reward rate
	dynamicRate := k.CalculateDynamicRewardRate(ctx)
	k.Logger(ctx).Info("Dynamic reward rate calculated", 
		"dynamicRate", dynamicRate,
		"annualPercentage", math.LegacyNewDecFromInt(dynamicRate).Quo(math.LegacyNewDec(3175)).Mul(math.LegacyNewDec(100)),
		"baseRate", 222,
	)
	
	// Calculate total liquidity from ALL orders
	userLiquidity := make(map[string]math.LegacyDec)
	totalLiquidity := math.LegacyZeroDec()
	
	// Walk through ALL orders
	err := k.Orders.Walk(ctx, nil, func(orderID uint64, order types.Order) (bool, error) {
		// Skip filled orders
		remaining := order.Amount.Amount.Sub(order.FilledAmount.Amount)
		if remaining.IsZero() {
			return false, nil
		}
		
		// Calculate order value
		remainingDec := math.LegacyNewDecFromInt(remaining).Quo(math.LegacyNewDec(1000000))
		priceDec := math.LegacyNewDecFromInt(order.Price.Amount).Quo(math.LegacyNewDec(1000000))
		orderValue := remainingDec.Mul(priceDec)
		
		// Add to user's total liquidity
		if _, exists := userLiquidity[order.Maker]; !exists {
			userLiquidity[order.Maker] = math.LegacyZeroDec()
		}
		userLiquidity[order.Maker] = userLiquidity[order.Maker].Add(orderValue)
		totalLiquidity = totalLiquidity.Add(orderValue)
		
		return false, nil
	})
	if err != nil {
		return err
	}
	
	// If no liquidity, nothing to distribute
	if totalLiquidity.IsZero() || len(userLiquidity) == 0 {
		k.Logger(ctx).Info("No eligible liquidity for rewards")
		return nil
	}
	
	// Calculate total rewards to distribute this hour
	// Dynamic rate: e.g., 3175 = 100% APR
	annualRate := math.LegacyNewDecFromInt(dynamicRate).Quo(math.LegacyNewDec(3175))
	hoursPerYear := math.LegacyNewDec(BlocksPerYear).Quo(math.LegacyNewDec(BlocksPerHour))
	hourlyRate := annualRate.Quo(hoursPerYear)
	
	// Total rewards = total liquidity * hourly rate
	totalRewardsDecimal := totalLiquidity.Mul(hourlyRate)
	totalRewards := totalRewardsDecimal.Mul(math.LegacyNewDec(1000000)).TruncateInt()
	
	k.Logger(ctx).Info("Total rewards to distribute",
		"totalWeightedLiquidity", totalLiquidity,
		"totalRewards", totalRewards,
		"numProviders", len(userLiquidity),
	)
	
	// If rewards are too small, skip
	if totalRewards.IsZero() {
		k.Logger(ctx).Info("Rewards too small to distribute")
		return nil
	}
	
	// Mint the rewards
	coins := sdk.NewCoins(sdk.NewCoin("ulc", totalRewards))
	err = k.bankKeeper.MintCoins(ctx, "mint", coins)
	if err != nil {
		return fmt.Errorf("failed to mint LC rewards: %w", err)
	}
	
	// Transfer to DEX module
	err = k.bankKeeper.SendCoinsFromModuleToModule(ctx, "mint", types.ModuleName, coins)
	if err != nil {
		return fmt.Errorf("failed to transfer LC rewards to DEX module: %w", err)
	}
	
	// Distribute proportionally to each user
	for userAddr, liquidity := range userLiquidity {
		// Calculate user's share
		userShare := liquidity.Quo(totalLiquidity)
		userRewardsInt := math.LegacyNewDecFromInt(totalRewards).Mul(userShare).TruncateInt()
		
		if userRewardsInt.IsZero() {
			continue
		}
		
		// Update user rewards
		userReward := types.UserReward{
			Address:        userAddr,
			TotalRewards:   userRewardsInt,
			ClaimedRewards: math.ZeroInt(),
		}
		
		// Get existing rewards if any
		existing, err := k.UserRewards.Get(ctx, userAddr)
		if err == nil {
			userReward.TotalRewards = userReward.TotalRewards.Add(existing.TotalRewards)
			userReward.ClaimedRewards = existing.ClaimedRewards
		}
		
		if err := k.UserRewards.Set(ctx, userAddr, userReward); err != nil {
			k.Logger(ctx).Error("failed to update user rewards", "user", userAddr, "error", err)
		}
		
		k.Logger(ctx).Info("Distributed LC rewards to user",
			"user", userAddr,
			"rewards", userRewardsInt,
			"liquidity", liquidity,
		)
	}
	
	return nil
}