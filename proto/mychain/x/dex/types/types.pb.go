// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mychain/dex/v1/types.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Order defines a trading order
type Order struct {
	Id           uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Maker        string     `protobuf:"bytes,2,opt,name=maker,proto3" json:"maker,omitempty"`
	PairId       uint64     `protobuf:"varint,3,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	IsBuy        bool       `protobuf:"varint,4,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	Price        types.Coin `protobuf:"bytes,5,opt,name=price,proto3" json:"price"`
	Amount       types.Coin `protobuf:"bytes,6,opt,name=amount,proto3" json:"amount"`
	FilledAmount types.Coin `protobuf:"bytes,7,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount"`
	CreatedAt    int64      `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt    int64      `protobuf:"varint,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{0}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetMaker() string {
	if m != nil {
		return m.Maker
	}
	return ""
}

func (m *Order) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *Order) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *Order) GetPrice() types.Coin {
	if m != nil {
		return m.Price
	}
	return types.Coin{}
}

func (m *Order) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *Order) GetFilledAmount() types.Coin {
	if m != nil {
		return m.FilledAmount
	}
	return types.Coin{}
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

// TradingPair defines a trading pair
type TradingPair struct {
	Id         uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BaseDenom  string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	Active     bool   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *TradingPair) Reset()         { *m = TradingPair{} }
func (m *TradingPair) String() string { return proto.CompactTextString(m) }
func (*TradingPair) ProtoMessage()    {}
func (*TradingPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{1}
}
func (m *TradingPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingPair.Merge(m, src)
}
func (m *TradingPair) XXX_Size() int {
	return m.Size()
}
func (m *TradingPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingPair.DiscardUnknown(m)
}

var xxx_messageInfo_TradingPair proto.InternalMessageInfo

func (m *TradingPair) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TradingPair) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *TradingPair) GetQuoteDenom() string {
	if m != nil {
		return m.QuoteDenom
	}
	return ""
}

func (m *TradingPair) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// LiquidityTier defines reward tiers based on price deviation
type LiquidityTier struct {
	Id                    uint32                      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PriceDeviation        cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price_deviation,json=priceDeviation,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price_deviation"`
	BidVolumeCap          cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=bid_volume_cap,json=bidVolumeCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"bid_volume_cap"`
	AskVolumeCap          cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=ask_volume_cap,json=askVolumeCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"ask_volume_cap"`
	WindowDurationSeconds int64                       `protobuf:"varint,5,opt,name=window_duration_seconds,json=windowDurationSeconds,proto3" json:"window_duration_seconds,omitempty"`
}

func (m *LiquidityTier) Reset()         { *m = LiquidityTier{} }
func (m *LiquidityTier) String() string { return proto.CompactTextString(m) }
func (*LiquidityTier) ProtoMessage()    {}
func (*LiquidityTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{2}
}
func (m *LiquidityTier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTier.Merge(m, src)
}
func (m *LiquidityTier) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTier) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTier.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTier proto.InternalMessageInfo

func (m *LiquidityTier) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LiquidityTier) GetWindowDurationSeconds() int64 {
	if m != nil {
		return m.WindowDurationSeconds
	}
	return 0
}

// OrderRewardInfo tracks reward information for individual orders
type OrderRewardInfo struct {
	OrderId         uint64                `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	TierId          uint32                `protobuf:"varint,2,opt,name=tier_id,json=tierId,proto3" json:"tier_id,omitempty"`
	StartTime       int64                 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	LastUpdated     int64                 `protobuf:"varint,4,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	AccumulatedTime int64                 `protobuf:"varint,5,opt,name=accumulated_time,json=accumulatedTime,proto3" json:"accumulated_time,omitempty"`
	TotalRewards    cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=total_rewards,json=totalRewards,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards"`
	LastClaimedTime int64                 `protobuf:"varint,7,opt,name=last_claimed_time,json=lastClaimedTime,proto3" json:"last_claimed_time,omitempty"`
}

func (m *OrderRewardInfo) Reset()         { *m = OrderRewardInfo{} }
func (m *OrderRewardInfo) String() string { return proto.CompactTextString(m) }
func (*OrderRewardInfo) ProtoMessage()    {}
func (*OrderRewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{3}
}
func (m *OrderRewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderRewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderRewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderRewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRewardInfo.Merge(m, src)
}
func (m *OrderRewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *OrderRewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRewardInfo proto.InternalMessageInfo

func (m *OrderRewardInfo) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *OrderRewardInfo) GetTierId() uint32 {
	if m != nil {
		return m.TierId
	}
	return 0
}

func (m *OrderRewardInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *OrderRewardInfo) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *OrderRewardInfo) GetAccumulatedTime() int64 {
	if m != nil {
		return m.AccumulatedTime
	}
	return 0
}

func (m *OrderRewardInfo) GetLastClaimedTime() int64 {
	if m != nil {
		return m.LastClaimedTime
	}
	return 0
}

// VolumeTracker tracks volume for tier calculations
type VolumeTracker struct {
	PairId  uint64         `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	Windows []VolumeWindow `protobuf:"bytes,2,rep,name=windows,proto3" json:"windows"`
}

func (m *VolumeTracker) Reset()         { *m = VolumeTracker{} }
func (m *VolumeTracker) String() string { return proto.CompactTextString(m) }
func (*VolumeTracker) ProtoMessage()    {}
func (*VolumeTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{4}
}
func (m *VolumeTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeTracker.Merge(m, src)
}
func (m *VolumeTracker) XXX_Size() int {
	return m.Size()
}
func (m *VolumeTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeTracker.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeTracker proto.InternalMessageInfo

func (m *VolumeTracker) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *VolumeTracker) GetWindows() []VolumeWindow {
	if m != nil {
		return m.Windows
	}
	return nil
}

// VolumeWindow represents volume in a time window
type VolumeWindow struct {
	StartTime int64                 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	BidVolume cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=bid_volume,json=bidVolume,proto3,customtype=cosmossdk.io/math.Int" json:"bid_volume"`
	AskVolume cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=ask_volume,json=askVolume,proto3,customtype=cosmossdk.io/math.Int" json:"ask_volume"`
}

func (m *VolumeWindow) Reset()         { *m = VolumeWindow{} }
func (m *VolumeWindow) String() string { return proto.CompactTextString(m) }
func (*VolumeWindow) ProtoMessage()    {}
func (*VolumeWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{5}
}
func (m *VolumeWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeWindow.Merge(m, src)
}
func (m *VolumeWindow) XXX_Size() int {
	return m.Size()
}
func (m *VolumeWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeWindow.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeWindow proto.InternalMessageInfo

func (m *VolumeWindow) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *VolumeWindow) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// PriceReference tracks reference prices for tier calculations
type PriceReference struct {
	PairId         uint64                      `protobuf:"varint,1,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty"`
	ReferencePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=reference_price,json=referencePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"reference_price"`
	LastUpdated    int64                       `protobuf:"varint,3,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
}

func (m *PriceReference) Reset()         { *m = PriceReference{} }
func (m *PriceReference) String() string { return proto.CompactTextString(m) }
func (*PriceReference) ProtoMessage()    {}
func (*PriceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{6}
}
func (m *PriceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceReference.Merge(m, src)
}
func (m *PriceReference) XXX_Size() int {
	return m.Size()
}
func (m *PriceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceReference.DiscardUnknown(m)
}

var xxx_messageInfo_PriceReference proto.InternalMessageInfo

func (m *PriceReference) GetPairId() uint64 {
	if m != nil {
		return m.PairId
	}
	return 0
}

func (m *PriceReference) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

// UserReward contains user LC rewards summary
type UserReward struct {
	Address        string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	TotalRewards   cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_rewards,json=totalRewards,proto3,customtype=cosmossdk.io/math.Int" json:"total_rewards"`
	ClaimedRewards cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=claimed_rewards,json=claimedRewards,proto3,customtype=cosmossdk.io/math.Int" json:"claimed_rewards"`
}

func (m *UserReward) Reset()         { *m = UserReward{} }
func (m *UserReward) String() string { return proto.CompactTextString(m) }
func (*UserReward) ProtoMessage()    {}
func (*UserReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{7}
}
func (m *UserReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserReward.Merge(m, src)
}
func (m *UserReward) XXX_Size() int {
	return m.Size()
}
func (m *UserReward) XXX_DiscardUnknown() {
	xxx_messageInfo_UserReward.DiscardUnknown(m)
}

var xxx_messageInfo_UserReward proto.InternalMessageInfo

func (m *UserReward) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// UserRewardInfo contains user LC rewards information
type UserRewardInfo struct {
	Address      string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	PendingLc    cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=pending_lc,json=pendingLc,proto3,customtype=cosmossdk.io/math.Int" json:"pending_lc"`
	ClaimedLc    cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=claimed_lc,json=claimedLc,proto3,customtype=cosmossdk.io/math.Int" json:"claimed_lc"`
	OrderRewards []OrderRewardInfo     `protobuf:"bytes,4,rep,name=order_rewards,json=orderRewards,proto3" json:"order_rewards"`
}

func (m *UserRewardInfo) Reset()         { *m = UserRewardInfo{} }
func (m *UserRewardInfo) String() string { return proto.CompactTextString(m) }
func (*UserRewardInfo) ProtoMessage()    {}
func (*UserRewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{8}
}
func (m *UserRewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRewardInfo.Merge(m, src)
}
func (m *UserRewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserRewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserRewardInfo proto.InternalMessageInfo

func (m *UserRewardInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *UserRewardInfo) GetOrderRewards() []OrderRewardInfo {
	if m != nil {
		return m.OrderRewards
	}
	return nil
}

// DynamicRewardState tracks the current state of the dynamic reward system
type DynamicRewardState struct {
	// Current annual reward rate (between 7% and 100%)
	CurrentAnnualRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=current_annual_rate,json=currentAnnualRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_annual_rate"`
	// Last update block height
	LastUpdateBlock int64 `protobuf:"varint,2,opt,name=last_update_block,json=lastUpdateBlock,proto3" json:"last_update_block,omitempty"`
	// Last update time in unix seconds
	LastUpdateTime int64 `protobuf:"varint,3,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// Volume snapshots for historical tracking
	VolumeHistory []VolumeSnapshot `protobuf:"bytes,4,rep,name=volume_history,json=volumeHistory,proto3" json:"volume_history"`
}

func (m *DynamicRewardState) Reset()         { *m = DynamicRewardState{} }
func (m *DynamicRewardState) String() string { return proto.CompactTextString(m) }
func (*DynamicRewardState) ProtoMessage()    {}
func (*DynamicRewardState) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{9}
}
func (m *DynamicRewardState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicRewardState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicRewardState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicRewardState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicRewardState.Merge(m, src)
}
func (m *DynamicRewardState) XXX_Size() int {
	return m.Size()
}
func (m *DynamicRewardState) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicRewardState.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicRewardState proto.InternalMessageInfo

func (m *DynamicRewardState) GetLastUpdateBlock() int64 {
	if m != nil {
		return m.LastUpdateBlock
	}
	return 0
}

func (m *DynamicRewardState) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *DynamicRewardState) GetVolumeHistory() []VolumeSnapshot {
	if m != nil {
		return m.VolumeHistory
	}
	return nil
}

// VolumeSnapshot tracks trading volume at a specific point in time
type VolumeSnapshot struct {
	BlockHeight int64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Timestamp   int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Trading volume in the last hour
	HourlyVolume cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=hourly_volume,json=hourlyVolume,proto3,customtype=cosmossdk.io/math.Int" json:"hourly_volume"`
	// Current liquidity depth (total value in order books)
	LiquidityDepth cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=liquidity_depth,json=liquidityDepth,proto3,customtype=cosmossdk.io/math.Int" json:"liquidity_depth"`
}

func (m *VolumeSnapshot) Reset()         { *m = VolumeSnapshot{} }
func (m *VolumeSnapshot) String() string { return proto.CompactTextString(m) }
func (*VolumeSnapshot) ProtoMessage()    {}
func (*VolumeSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_365ac4383fac3c97, []int{10}
}
func (m *VolumeSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeSnapshot.Merge(m, src)
}
func (m *VolumeSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *VolumeSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeSnapshot proto.InternalMessageInfo

func (m *VolumeSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *VolumeSnapshot) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func init() {
	proto.RegisterType((*Order)(nil), "mychain.dex.v1.Order")
	proto.RegisterType((*TradingPair)(nil), "mychain.dex.v1.TradingPair")
	proto.RegisterType((*LiquidityTier)(nil), "mychain.dex.v1.LiquidityTier")
	proto.RegisterType((*OrderRewardInfo)(nil), "mychain.dex.v1.OrderRewardInfo")
	proto.RegisterType((*VolumeTracker)(nil), "mychain.dex.v1.VolumeTracker")
	proto.RegisterType((*VolumeWindow)(nil), "mychain.dex.v1.VolumeWindow")
	proto.RegisterType((*PriceReference)(nil), "mychain.dex.v1.PriceReference")
	proto.RegisterType((*UserReward)(nil), "mychain.dex.v1.UserReward")
	proto.RegisterType((*UserRewardInfo)(nil), "mychain.dex.v1.UserRewardInfo")
	proto.RegisterType((*DynamicRewardState)(nil), "mychain.dex.v1.DynamicRewardState")
	proto.RegisterType((*VolumeSnapshot)(nil), "mychain.dex.v1.VolumeSnapshot")
}

func init() { proto.RegisterFile("mychain/dex/v1/types.proto", fileDescriptor_365ac4383fac3c97) }

var fileDescriptor_365ac4383fac3c97 = []byte{
	// 1090 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x25, 0x5b, 0xb2, 0x46, 0x7f, 0x09, 0x93, 0x34, 0xb2, 0x1b, 0xcb, 0xaa, 0x7a, 0x51,
	0x0b, 0x94, 0x82, 0x53, 0xb4, 0xbd, 0xf8, 0x62, 0x59, 0x08, 0xa2, 0x56, 0x40, 0x03, 0xda, 0x69,
	0x81, 0x5e, 0x88, 0xd5, 0xee, 0xda, 0x5a, 0x98, 0xe4, 0x32, 0xdc, 0xa5, 0x6c, 0xbd, 0x43, 0x0f,
	0x3d, 0xf7, 0xd8, 0x47, 0xe8, 0xb5, 0xd7, 0x1e, 0x72, 0x4c, 0x6f, 0x45, 0x81, 0x06, 0x85, 0xfd,
	0x06, 0x7d, 0x82, 0x62, 0x7f, 0x68, 0xf9, 0xa7, 0x41, 0xe4, 0x9b, 0x76, 0x66, 0xbe, 0xd9, 0x8f,
	0x1f, 0xbf, 0x19, 0x11, 0x36, 0xa3, 0x39, 0x9e, 0x22, 0x16, 0xf7, 0x09, 0x3d, 0xeb, 0xcf, 0x76,
	0xfa, 0x72, 0x9e, 0x50, 0xe1, 0x25, 0x29, 0x97, 0xdc, 0x6d, 0xd8, 0x9c, 0x47, 0xe8, 0x99, 0x37,
	0xdb, 0xd9, 0x7c, 0x78, 0xcc, 0x8f, 0xb9, 0x4e, 0xf5, 0xd5, 0x2f, 0x53, 0xb5, 0xd9, 0xc6, 0x5c,
	0x44, 0x5c, 0xf4, 0x27, 0x48, 0xd0, 0xfe, 0x6c, 0x67, 0x42, 0x25, 0xda, 0xe9, 0x63, 0xce, 0x62,
	0x93, 0xef, 0xfe, 0x51, 0x80, 0xb5, 0x6f, 0x53, 0x42, 0x53, 0xb7, 0x01, 0x05, 0x46, 0x5a, 0x4e,
	0xc7, 0xe9, 0xad, 0xfa, 0x05, 0x46, 0xdc, 0x87, 0xb0, 0x16, 0xa1, 0x13, 0x9a, 0xb6, 0x0a, 0x1d,
	0xa7, 0x57, 0xf1, 0xcd, 0xc1, 0x7d, 0x0c, 0xe5, 0x04, 0xb1, 0x34, 0x60, 0xa4, 0x55, 0xd4, 0xa5,
	0x25, 0x75, 0x1c, 0x11, 0xf7, 0x11, 0x94, 0x98, 0x08, 0x26, 0xd9, 0xbc, 0xb5, 0xda, 0x71, 0x7a,
	0xeb, 0xfe, 0x1a, 0x13, 0x83, 0x6c, 0xee, 0x7e, 0x01, 0x6b, 0x49, 0xca, 0x30, 0x6d, 0xad, 0x75,
	0x9c, 0x5e, 0xf5, 0xe9, 0x86, 0x67, 0xf8, 0x78, 0x8a, 0x8f, 0x67, 0xf9, 0x78, 0xfb, 0x9c, 0xc5,
	0x83, 0xd5, 0xd7, 0x6f, 0xb7, 0x57, 0x7c, 0x53, 0xed, 0x7e, 0x05, 0x25, 0x14, 0xf1, 0x2c, 0x96,
	0xad, 0xd2, 0x72, 0x38, 0x5b, 0xee, 0x0e, 0xa1, 0x7e, 0xc4, 0xc2, 0x90, 0x92, 0xc0, 0xe2, 0xcb,
	0xcb, 0xe1, 0x6b, 0x06, 0xb5, 0x67, 0xba, 0x6c, 0x01, 0xe0, 0x94, 0x22, 0xa9, 0xda, 0xc8, 0xd6,
	0x7a, 0xc7, 0xe9, 0x15, 0xfd, 0x8a, 0x8d, 0xec, 0xe9, 0x74, 0x96, 0x90, 0x3c, 0x5d, 0x31, 0x69,
	0x1b, 0xd9, 0x93, 0xdd, 0x0c, 0xaa, 0x87, 0x29, 0x22, 0x2c, 0x3e, 0x7e, 0x81, 0xd8, 0x6d, 0x61,
	0xb7, 0x00, 0x14, 0x8b, 0x80, 0xd0, 0x98, 0x47, 0x56, 0xdd, 0x8a, 0x8a, 0x0c, 0x55, 0xc0, 0xdd,
	0x86, 0xea, 0xab, 0x8c, 0xcb, 0x3c, 0x5f, 0xd4, 0x79, 0xd0, 0x21, 0x53, 0xf0, 0x01, 0x94, 0x10,
	0x96, 0x6c, 0x46, 0xad, 0xd2, 0xf6, 0xd4, 0xfd, 0xad, 0x00, 0xf5, 0x31, 0x7b, 0x95, 0x31, 0xc2,
	0xe4, 0xfc, 0x90, 0x5d, 0x7b, 0xa5, 0x75, 0x7d, 0xf3, 0x18, 0x9a, 0x5a, 0xde, 0x80, 0xd0, 0x19,
	0x43, 0x92, 0xf1, 0xd8, 0x5c, 0x3f, 0xf8, 0x58, 0x69, 0xf0, 0xd7, 0xdb, 0xed, 0x0f, 0x8d, 0x4a,
	0x82, 0x9c, 0x78, 0x8c, 0xf7, 0x23, 0x24, 0xa7, 0xde, 0x98, 0x1e, 0x23, 0x3c, 0x1f, 0x52, 0xec,
	0x37, 0x34, 0x76, 0x98, 0x43, 0xdd, 0x11, 0x34, 0x26, 0x8c, 0x04, 0x33, 0x1e, 0x66, 0x11, 0x0d,
	0x30, 0x4a, 0x0c, 0xd7, 0xe5, 0x9a, 0xd5, 0x26, 0x8c, 0x7c, 0xa7, 0x91, 0xfb, 0x28, 0x51, 0xad,
	0x90, 0x38, 0xb9, 0xda, 0x6a, 0xf5, 0x0e, 0xad, 0x90, 0x38, 0x59, 0xb4, 0xfa, 0x12, 0x1e, 0x9f,
	0xb2, 0x98, 0xf0, 0xd3, 0x80, 0x64, 0xa9, 0x26, 0x1a, 0x08, 0x8a, 0x79, 0x4c, 0x84, 0xb6, 0x60,
	0xd1, 0x7f, 0x64, 0xd2, 0x43, 0x9b, 0x3d, 0x30, 0xc9, 0xee, 0x2f, 0x05, 0x68, 0xea, 0x41, 0xf0,
	0xe9, 0x29, 0x4a, 0xc9, 0x28, 0x3e, 0xe2, 0xee, 0x06, 0xac, 0x73, 0x15, 0x0a, 0x2e, 0xdf, 0x5f,
	0x59, 0x9f, 0x47, 0x44, 0xcd, 0x81, 0x64, 0x26, 0x53, 0xd0, 0xfa, 0x96, 0xd4, 0x71, 0xa4, 0xdf,
	0xae, 0x90, 0x28, 0x95, 0x81, 0x64, 0x11, 0xd5, 0x8a, 0x14, 0xfd, 0x8a, 0x8e, 0x1c, 0xb2, 0x88,
	0xba, 0x1f, 0x41, 0x2d, 0x44, 0x42, 0x06, 0xd6, 0x2d, 0xfa, 0x39, 0x8b, 0x7e, 0x55, 0xc5, 0x5e,
	0x9a, 0x90, 0xfb, 0x09, 0xdc, 0x43, 0x18, 0x67, 0x51, 0x16, 0x6a, 0x87, 0xe9, 0x3e, 0x86, 0x7a,
	0xf3, 0x4a, 0x5c, 0x77, 0x1b, 0x40, 0x5d, 0x72, 0x89, 0xc2, 0x20, 0xd5, 0xa4, 0x85, 0x9e, 0x96,
	0xca, 0x60, 0xcb, 0xca, 0xf6, 0xe8, 0xb6, 0x6c, 0xa3, 0x58, 0xfa, 0x35, 0x8d, 0x31, 0xcf, 0x29,
	0xdc, 0x4f, 0xe1, 0xbe, 0x66, 0x84, 0x43, 0xc4, 0xa2, 0xfc, 0xbe, 0xb2, 0xb9, 0x4f, 0x25, 0xf6,
	0x4d, 0x5c, 0xdd, 0xd7, 0x3d, 0x82, 0xba, 0x51, 0xfa, 0x30, 0x45, 0xf8, 0xc6, 0x3a, 0x70, 0xae,
	0xad, 0x83, 0x5d, 0x28, 0x1b, 0x9d, 0x45, 0xab, 0xd0, 0x29, 0xf6, 0xaa, 0x4f, 0x9f, 0x78, 0xd7,
	0xf7, 0x95, 0x67, 0x1a, 0x7d, 0xaf, 0x8b, 0xec, 0x10, 0xe6, 0x90, 0xee, 0xef, 0x0e, 0xd4, 0xae,
	0xe6, 0x6f, 0xa8, 0xea, 0xdc, 0x54, 0x75, 0x03, 0xd6, 0x69, 0x6c, 0xa9, 0x17, 0x74, 0xb2, 0x4c,
	0x63, 0x23, 0xd1, 0x2e, 0xc0, 0xc2, 0xa5, 0xd6, 0xa1, 0xef, 0xd1, 0xa7, 0x72, 0xe9, 0x4d, 0x85,
	0x5e, 0x18, 0xd3, 0x9a, 0xf2, 0x7d, 0xe8, 0x4b, 0x3b, 0x76, 0x7f, 0x76, 0xa0, 0xf1, 0x42, 0x0d,
	0x8d, 0x4f, 0x8f, 0x68, 0x4a, 0x63, 0x4c, 0xdf, 0x2d, 0xd8, 0x18, 0x9a, 0x69, 0x5e, 0x15, 0x98,
	0x95, 0x79, 0x97, 0xd9, 0xbc, 0xc4, 0xea, 0xfb, 0x6e, 0xd9, 0xac, 0x78, 0xcb, 0x66, 0xdd, 0x5f,
	0x1d, 0x80, 0x97, 0x22, 0xf7, 0xbb, 0xdb, 0x82, 0x32, 0x22, 0x24, 0xa5, 0x42, 0x68, 0x62, 0x15,
	0x3f, 0x3f, 0xde, 0x36, 0x59, 0xe1, 0xee, 0x26, 0x7b, 0x06, 0xcd, 0xdc, 0x5f, 0x79, 0x97, 0xa5,
	0x5e, 0x45, 0xc3, 0xa2, 0x6c, 0x9f, 0xee, 0xbf, 0x0e, 0x34, 0x16, 0xa4, 0xf5, 0x90, 0xbe, 0x9b,
	0xf8, 0x2e, 0x40, 0x42, 0x63, 0xb5, 0x87, 0x83, 0x10, 0x2f, 0xc7, 0xba, 0x62, 0x01, 0x63, 0xac,
	0xd0, 0x39, 0xe5, 0x10, 0x2f, 0x69, 0x1c, 0x0b, 0x18, 0x63, 0xf7, 0x6b, 0xa8, 0x9b, 0xd5, 0x91,
	0x3f, 0xee, 0xaa, 0x9e, 0x82, 0xed, 0x9b, 0x53, 0x70, 0x63, 0xe5, 0xe4, 0xff, 0x46, 0x7c, 0x11,
	0x16, 0xdd, 0x1f, 0x0b, 0xe0, 0x0e, 0xe7, 0x31, 0x8a, 0x18, 0x36, 0xa1, 0x03, 0x89, 0x24, 0x75,
	0x0f, 0xe0, 0x01, 0xce, 0xd2, 0x94, 0xc6, 0x32, 0x40, 0x71, 0x9c, 0xa9, 0x17, 0x84, 0xa4, 0x19,
	0x8e, 0x25, 0x5d, 0x73, 0xdf, 0xe2, 0xf7, 0x34, 0xdc, 0x57, 0x4d, 0xf3, 0x6d, 0x60, 0x8c, 0x13,
	0x4c, 0x42, 0x8e, 0x4f, 0xec, 0x48, 0x35, 0x17, 0xee, 0x19, 0xa8, 0xb0, 0xdb, 0x83, 0x7b, 0x57,
	0x6b, 0xaf, 0x2c, 0xbc, 0xc6, 0xa2, 0x54, 0x0f, 0xe1, 0x37, 0xd0, 0xb0, 0xbb, 0x7d, 0xca, 0x84,
	0xe4, 0xe9, 0xdc, 0xca, 0xd1, 0xfe, 0xff, 0xa5, 0x70, 0x10, 0xa3, 0x44, 0x4c, 0xb9, 0xb4, 0x6a,
	0xd4, 0x0d, 0xf6, 0xb9, 0x81, 0x76, 0xff, 0x76, 0xa0, 0x71, 0xbd, 0x4e, 0xd9, 0x5d, 0x33, 0x0d,
	0xa6, 0x94, 0x1d, 0x4f, 0xa5, 0x5d, 0x10, 0x55, 0x1d, 0x7b, 0xae, 0x43, 0xee, 0x13, 0xa8, 0x28,
	0x82, 0x42, 0xa2, 0x28, 0xb1, 0x0f, 0xb4, 0x08, 0x28, 0x8f, 0x4f, 0x79, 0x96, 0x86, 0xf3, 0x3b,
	0x2d, 0x8a, 0x9a, 0xc1, 0xd8, 0x5d, 0xf1, 0x0c, 0x9a, 0x61, 0xfe, 0xf7, 0x1b, 0x10, 0x9a, 0xc8,
	0xe9, 0x72, 0x0b, 0xa3, 0x71, 0x89, 0x1a, 0x2a, 0xd0, 0xe0, 0xb3, 0xd7, 0xe7, 0x6d, 0xe7, 0xcd,
	0x79, 0xdb, 0xf9, 0xe7, 0xbc, 0xed, 0xfc, 0x74, 0xd1, 0x5e, 0x79, 0x73, 0xd1, 0x5e, 0xf9, 0xf3,
	0xa2, 0xbd, 0xf2, 0xc3, 0x83, 0xfc, 0x73, 0xf0, 0x4c, 0x7f, 0x10, 0xea, 0xaf, 0xc1, 0x49, 0x49,
	0x7f, 0xc8, 0x7d, 0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x49, 0x25, 0xb5, 0x29, 0x2c, 0x0a,
	0x00, 0x00,
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.FilledAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Maker) > 0 {
		i -= len(m.Maker)
		copy(dAtA[i:], m.Maker)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Maker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TradingPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowDurationSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WindowDurationSeconds))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AskVolumeCap.Size()
		i -= size
		if _, err := m.AskVolumeCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidVolumeCap.Size()
		i -= size
		if _, err := m.BidVolumeCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PriceDeviation.Size()
		i -= size
		if _, err := m.PriceDeviation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderRewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderRewardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderRewardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastClaimedTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastClaimedTime))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.TotalRewards.Size()
		i -= size
		if _, err := m.TotalRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.AccumulatedTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AccumulatedTime))
		i--
		dAtA[i] = 0x28
	}
	if m.LastUpdated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.TierId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TierId))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VolumeTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Windows) > 0 {
		for iNdEx := len(m.Windows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Windows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VolumeWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AskVolume.Size()
		i -= size
		if _, err := m.AskVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidVolume.Size()
		i -= size
		if _, err := m.BidVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EndTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ReferencePrice.Size()
		i -= size
		if _, err := m.ReferencePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PairId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ClaimedRewards.Size()
		i -= size
		if _, err := m.ClaimedRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalRewards.Size()
		i -= size
		if _, err := m.TotalRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRewardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRewardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderRewards) > 0 {
		for iNdEx := len(m.OrderRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.ClaimedLc.Size()
		i -= size
		if _, err := m.ClaimedLc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PendingLc.Size()
		i -= size
		if _, err := m.PendingLc.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DynamicRewardState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicRewardState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicRewardState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VolumeHistory) > 0 {
		for iNdEx := len(m.VolumeHistory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VolumeHistory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x18
	}
	if m.LastUpdateBlock != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdateBlock))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.CurrentAnnualRate.Size()
		i -= size
		if _, err := m.CurrentAnnualRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VolumeSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LiquidityDepth.Size()
		i -= size
		if _, err := m.LiquidityDepth.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.HourlyVolume.Size()
		i -= size
		if _, err := m.HourlyVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Timestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.Maker)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if m.IsBuy {
		n += 2
	}
	l = m.Price.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.FilledAmount.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.UpdatedAt))
	}
	return n
}

func (m *TradingPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *LiquidityTier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = m.PriceDeviation.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.BidVolumeCap.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AskVolumeCap.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.WindowDurationSeconds != 0 {
		n += 1 + sovTypes(uint64(m.WindowDurationSeconds))
	}
	return n
}

func (m *OrderRewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovTypes(uint64(m.OrderId))
	}
	if m.TierId != 0 {
		n += 1 + sovTypes(uint64(m.TierId))
	}
	if m.StartTime != 0 {
		n += 1 + sovTypes(uint64(m.StartTime))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdated))
	}
	if m.AccumulatedTime != 0 {
		n += 1 + sovTypes(uint64(m.AccumulatedTime))
	}
	l = m.TotalRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastClaimedTime != 0 {
		n += 1 + sovTypes(uint64(m.LastClaimedTime))
	}
	return n
}

func (m *VolumeTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	if len(m.Windows) > 0 {
		for _, e := range m.Windows {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VolumeWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovTypes(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovTypes(uint64(m.EndTime))
	}
	l = m.BidVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AskVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *PriceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PairId != 0 {
		n += 1 + sovTypes(uint64(m.PairId))
	}
	l = m.ReferencePrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastUpdated != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdated))
	}
	return n
}

func (m *UserReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.TotalRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ClaimedRewards.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *UserRewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.PendingLc.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ClaimedLc.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.OrderRewards) > 0 {
		for _, e := range m.OrderRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DynamicRewardState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CurrentAnnualRate.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LastUpdateBlock != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdateBlock))
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdateTime))
	}
	if len(m.VolumeHistory) > 0 {
		for _, e := range m.VolumeHistory {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VolumeSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTypes(uint64(m.Timestamp))
	}
	l = m.HourlyVolume.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.LiquidityDepth.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FilledAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDeviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PriceDeviation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidVolumeCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidVolumeCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskVolumeCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskVolumeCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowDurationSeconds", wireType)
			}
			m.WindowDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderRewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderRewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderRewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TierId", wireType)
			}
			m.TierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TierId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedTime", wireType)
			}
			m.AccumulatedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumulatedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClaimedTime", wireType)
			}
			m.LastClaimedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastClaimedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Windows = append(m.Windows, VolumeWindow{})
			if err := m.Windows[len(m.Windows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReferencePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClaimedRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingLc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PendingLc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedLc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClaimedLc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderRewards = append(m.OrderRewards, OrderRewardInfo{})
			if err := m.OrderRewards[len(m.OrderRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicRewardState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicRewardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicRewardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentAnnualRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentAnnualRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateBlock", wireType)
			}
			m.LastUpdateBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeHistory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeHistory = append(m.VolumeHistory, VolumeSnapshot{})
			if err := m.VolumeHistory[len(m.VolumeHistory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HourlyVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityDepth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityDepth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
